package ebpf

import (
	"fmt"

	"github.com/cilium/ebpf"

	"github.com/cilium/ebpf/rlimit"
)

// In a real scenario, use bpf2go to generate these structs.
// For boilerplate, we'll define a placeholder wrapper.

type CipherTraceObjects struct {
	CipherTracePrograms
	CipherTraceMaps
}

type CipherTracePrograms struct {
	UretprobeSslCipherGetName *ebpf.Program `ebpf:"uretprobe_ssl_cipher_get_name"`
}

type CipherTraceMaps struct {
	Events *ebpf.Map `ebpf:"events"`
}

func (o *CipherTraceObjects) Close() error {
	return nil // Implement proper closing in real code generated by bpf2go
}

func LoadCipherTraceObjects() (*CipherTraceObjects, error) {
	// Allow current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock limit: %v", err)
	}

	// Load the ELF file
	spec, err := ebpf.LoadCollectionSpec("bpf_ciphertrace.o")
	if err != nil {
		return nil, fmt.Errorf("loading spec: %v", err)
	}

	var objs CipherTraceObjects
	if err := spec.LoadAndAssign(&objs, nil); err != nil {
		return nil, fmt.Errorf("loading objects: %v", err)
	}

	return &objs, nil
}
